<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#050510">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>METAVERSE NEON ASCENSION</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=zMUemoV1i33PBfcUFjiWk5SgbEQLqAullhURmpqTqeIv_PxEiDXGOXHDmVogmZcriTmTF4GusHNCGjxwsKYYoOpN4ZoU3YvUi1OzxzqW5u4Y2eCGc9IceVvPCYXZ_S8NMtOLa-P71cZwah4eVC0mvBaRv3NQTNmNZ6fNzIuVd00DH5B7dAYcDYKwA7euth6wK4hxYMKwk7YJceaG90fvDeydgwqFapDadndsUMtT2OUju5WxfqwmALx4tn9QlelRCjwdMz-0XuNm-cXicvaZl6gHjPDUPTQ9OdShkyUGwbodzZrJ_TEiKKZSsApMjflOpJdxX5Aqrey2MivjxQiR1xpVCVqbb2tmuPCU9XQ-Z578USZMPGNGKuMkk09f3G0hm-Ht7UsmUOS_gFtoWbbDQ5Yx9j26ZyKyfqJiuIeQZ1NpuS_gP1yoNaqt59EeBgCja9DpSm_neOMEO6dnpwScp1DjRqjunXB9PnXUxC_r390GpL_-k2Lc80QczEY8NG7__76v3LnaalOwA7ZWr8rnqvzbALBQhciXnYl76gGN_nle0I1L8yA3CCqNQqP_0v33heml4Sk4gK25h8vzywfHguhnq-9V0kiKGiXjSoehvZQwf5m1ISjFjwEwIpci6Xn0P2r0zRUlrYpBRmLkZEeQtBrfWd_2NwWFAoJCv6BPUX-DONiN5rNu121AuJynz8guvshfaYjiGaMc8Sfd4n7kgAugs0Hh5QAsdLvZPSbvQY4JQ6ikuqEgFBJKvE2LoYWmQLyLpmUEybYBGFlafG5w0ripbUfRAQ07saJNejckUi60IX-z8gKRYt33s7taGITBqtqdrpeaI27ZGB5sosH1mEYpY4DbgyAIl7q5xg2vF0LjUuaKC9vT-acMaaNWX1OdVKDqPrlUlxw3ZGriNKcyFbCkPWBvWAiiOEhKsnzFHrnuBVXrEZP1NK7RzKBM2QuwtP_IxBhQVlJcyx57myhlKQ27Hio-ZP0SvsLRjJlDfJ0KnazFIrjUHNpHuhadaPx16dabTKFvZ6dncb_wVPkpP-jyQShn4s9L_vOch9YRHWQvB6K1BeUTDNNHWforj--0xdDN4Y3DdxMynhRVp2ZNu95urv52pSgKXRZ4v-b6PpuhGc6CLx_jnMUW9ZIOhrIPElYyL8k2XSWp_U3n0YzwBQ7cGfhW10_W1DJpFmQAqTYgWB-oCwLvKwDjc45VnJxIQRXlJN71UtSgtgf483A1mCQJa1_ZlMM26eOtjc75o7vLbrYbzb90MqBTJfhD1hW7QUBUvGEKR8mc7oH2E526EPOoYMMR99JFZKUNXhplaXAKiZ5SKbGTLzu_Vdw1C57MQFurUxQmBa9qkqVQMTm2L84X1H07ppgd9pshO4_CY5jG_2PM3Y32IbocW5nXdiSsEXJzyW83hWmoy3fpCgi9rw6ALvKeCQqc7rEe7zF6Cq_DXGw5jOR5Cs6TLmUsxcS5-9-hZInP1RHVQgVOSyG4TB5cNAs-VgiYC-HI_VozaXnIhzL6igpZHYGmWZoHshCTDL3_GV7T-Jsj4-x7PfXfmmGiklaii8ddRxy2X2XTx4t28nZo0MbdiLhWPOSx_lQm_LaWBJdsPqYeDS6kbhy_QW65TeiLj2V1gsVjDHasBEOVhbiORh4FVgXaWZ4hNxAYss4iifWkUdgWAXjO6rH8tmLzigf6KkyreDViZNpTXOcUHQey9Qm3Ng8cEeLnEtfntdKUyudL0wjYBbtOsXHX_QnbhDtguc7WO0hs_EKYvI1pU-bjHHpTqeKsx3HcWXKtqsI0bjjCmK2M3hKrsS3wzajEbf7m4YfTyQGdKODzTgwPkMiZmAzc_WrkvY1beFyMgo_rdN-IBfuRj49GI0c5xeZeOAz5q9Mw1-25JOm5SXlc0zg4Rj2gUWjcP8tymXfutCWhpGblT0TsvnCZKO33CginituyI_Pze4MR_Yw_UzVukeCpgbgH-cS6MM3mLzAjSDajcNky5jHvFJ32rRKC6J7QXUPJAffDGtUSLibwiEpfms29PJFKDQGZjkrMuAVPCCe7_Y_q6kv-uC-Cm0NhTgFRvcyheujBizpzSwBhXzI5UfofjNRF852q7LnWVMHuvGP4iJ2ZURncO7R01LD6XJ5a1g5LzxdVcV28hEgMDvMAhP124jhB6WtUsmSJmc4ltaf5RBVItbjGRd7IuyQb1Ze4jyk0hdDVW_I8xu2P0ytyeGz3qlOdwPTp9vtEAZgKNz89K1C0Vwy8vKhWuaiV2A" charset="UTF-8"></script><style>
        :root { --neon-color: #00f3ff; --bg-color: #050510; }
        body {
            margin: 0; overflow: hidden; background-color: var(--bg-color);
            font-family: 'Orbitron', sans-serif; user-select: none;
        }
        body::after {
            content: " "; display: block; position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #hud-top {
            display: flex; justify-content: space-between; padding: 30px;
            text-shadow: 0 0 10px var(--neon-color); color: white;
        }
        .hud-box { border: 1px solid rgba(255,255,255,0.2); padding: 10px 20px; background: rgba(0,0,0,0.5); transform: skewX(-15deg); }
        .label { font-size: 12px; color: #aaa; display: block; }
        .value { font-size: 24px; font-weight: 900; color: var(--neon-color); }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: var(--neon-color); border-radius: 50%;
            transform: translate(-50%, -50%); box-shadow: 0 0 10px var(--neon-color);
        }
        #death-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 0, 0, 0.3); display: none; z-index: 150;
            animation: deathFlash 0.2s ease-out;
        }
        @keyframes deathFlash { from { background: rgba(255, 0, 0, 0.8); } to { background: rgba(255, 0, 0, 0.3); } }
        
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 300; backdrop-filter: blur(10px);
            pointer-events: auto;
        }
        #leaderboard-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 250; backdrop-filter: blur(10px);
            padding: 40px; overflow-y: auto; pointer-events: auto;
        }
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 200; backdrop-filter: blur(5px);
            pointer-events: auto; cursor: pointer; text-align: center;
        }
        h1 { font-size: 60px; color: white; text-shadow: 0 0 20px var(--neon-color); margin: 0; letter-spacing: 5px; }
        h2 { font-size: 40px; color: white; text-shadow: 0 0 20px var(--neon-color); margin: 20px 0; }
        .controls-info { margin-top: 20px; color: #888; font-size: 14px; line-height: 1.6; }
        .hidden { opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        
            position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px;
            background: rgba(0, 243, 255, 0.1); border: 2px solid rgba(0, 243, 255, 0.3);
            border-radius: 50%; display: none; z-index: 20; touch-action: none;
        }
        .joystick-stick {
            position: absolute; width: 50px; height: 50px;
            background: radial-gradient(circle, rgba(0,243,255,0.8), rgba(0,243,255,0.2));
            border: 2px solid var(--neon-color); border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.6);
        }
        
            position: absolute; bottom: 30px; right: 30px; width: 80px; height: 80px;
            background: transparent; border: 2px solid var(--neon-color);
            border-radius: 50%; color: var(--neon-color); font-size: 24px;
            font-family: 'Orbitron', sans-serif; cursor: pointer; z-index: 20;
            box-shadow: 0 0 15px var(--neon-color); display: none; touch-action: none;
            font-weight: 900;
        }
        
        @media (max-width: 768px) {
            .hud-box { padding: 8px 15px; font-size: 12px; margin: 5px 0; }
            .value { font-size: 18px; }
            .label { font-size: 10px; }
            h1 { font-size: 40px; }
            h2 { font-size: 30px; }
            .btn { padding: 10px 30px; font-size: 14px; }
            .form-group input { width: 200px; padding: 10px 15px; font-size: 14px; }
            .leaderboard-entry { padding: 12px 20px; font-size: 14px; margin: 8px 0; }
            .rank { min-width: 40px; }
            .name { margin: 0 15px; }
        }
        
        @media (max-width: 480px) {
            body { font-size: 12px; }
            .hud-box { padding: 6px 10px; margin: 3px 0; }
            .value { font-size: 14px; }
            .label { font-size: 8px; }
            h1 { font-size: 28px; letter-spacing: 2px; }
            .controls-info { font-size: 11px; }
            .btn { padding: 8px 20px; font-size: 12px; }
            .form-group input { width: 160px; padding: 8px 10px; font-size: 12px; }
            .leaderboard-entry { padding: 10px 15px; font-size: 12px; }
        }
        
        .btn {
            margin-top: 20px; padding: 12px 40px; font-size: 16px;
            background: transparent; color: var(--neon-color); border: 2px solid var(--neon-color);
            font-family: 'Orbitron', sans-serif; cursor: pointer; transition: 0.3s;
            box-shadow: 0 0 15px var(--neon-color); text-transform: uppercase;
        }
        .btn:hover { background: var(--neon-color); color: black; box-shadow: 0 0 40px var(--neon-color); }
        .btn-start { padding: 15px 50px; font-size: 20px; }
        
        .form-group {
            margin: 15px 0; display: flex; flex-direction: column; align-items: center;
        }
        .form-group input {
            padding: 12px 20px; font-size: 16px; background: rgba(0, 243, 255, 0.1);
            border: 2px solid var(--neon-color); color: var(--neon-color);
            font-family: 'Orbitron', sans-serif; text-align: center; width: 250px;
            outline: none; transition: 0.3s;
        }
        .form-group input:focus {
            box-shadow: 0 0 20px var(--neon-color); background: rgba(0, 243, 255, 0.2);
        }
        .form-group input::placeholder { color: rgba(0, 243, 255, 0.5); }
        
        .leaderboard-entry {
            background: rgba(0, 243, 255, 0.05); border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 15px 30px; margin: 10px 0; width: 100%; max-width: 500px;
            border-radius: 5px; display: flex; justify-content: space-between; align-items: center;
            color: white; font-size: 18px; transition: 0.3s;
        }
        .leaderboard-entry:hover {
            background: rgba(0, 243, 255, 0.15); box-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
        }
        .rank { color: var(--neon-color); font-weight: 900; min-width: 50px; }
        .name { flex: 1; margin: 0 30px; }
        .score { color: #ff00ff; font-weight: 900; }
        
        #player-name-display { font-size: 18px; color: var(--neon-color); margin-bottom: 30px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="death-overlay"></div>
    
    <div id="login-screen">
        <h1>METAVERSE<br><span style="font-size:30px; color:#ff00ff">NEON ASCENSION</span></h1>
        <p style="color: #888; margin-top: 20px; font-size: 14px;">Accedi o crea un nuovo profilo</p>
        <div class="form-group">
            <input type="text" id="login-username" placeholder="Inserisci il tuo nome" maxlength="20">
        </div>
        <button class="btn btn-start" onclick="initializeGame()">AVVIA GIOCO</button>
        <button class="btn" onclick="showLeaderboard()">CLASSIFICA</button>
    </div>

    <div id="leaderboard-screen">
        <h2>CLASSIFICA GLOBALE</h2>
        <div id="leaderboard-list" style="width: 100%; display: flex; flex-direction: column; align-items: center;">
        </div>
        <button class="btn" onclick="backToLogin()" style="margin-top: 40px;">TORNA AL LOGIN</button>
    </div>

    <div id="ui-layer">
        <div id="hud-top">
            <div class="hud-box">
                <span class="label">GIOCATORE</span>
                <span class="value" id="player-val">---</span>
            </div>
            <div class="hud-box">
                <span class="label">LEVEL</span>
                <span class="value" id="level-val">01 / 100</span>
            </div>
            <div class="hud-box">
                <span class="label">FPS</span>
                <span class="value" id="fps-val">60</span>
            </div>
        </div>
        <div id="crosshair"></div>
    </div>

    <div id="start-screen">
        <h1>METAVERSE<br><span style="font-size:30px; color:#ff00ff">NEON ASCENSION</span></h1>
        <p id="player-name-display"></p>
        <p class="controls-info" id="controls-info-text">
            [WASD] MUOVITI &nbsp;|&nbsp; [SPACE] SALTA &nbsp;|&nbsp; [MOUSE] GUARDA<br>
            Raggiungi il PORTALE per caricare il prossimo settore.
        </p>
        <button class="btn btn-start" onclick="startGameSession()">INIZIA SESSIONE</button>
    </div>
    
    <div id="mobile-controls">
        <div class="joystick-stick" id="joystick-stick"></div>
    </div>
    <button id="jump-btn">JUMP</button>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- DATI LOCALI JSON BIN ---
        const JSONBIN_URL = "https://jsonbin.io/v3";
        const JSONBIN_KEY = "YOUR_JSONBIN_API_KEY"; // Cambia con la tua chiave o usa localStorage fallback
        
        let gameData = {
            players: []
        };

        async function saveScore(playerName, level) {
            const existingPlayer = gameData.players.find(p => p.name.toLowerCase() === playerName.toLowerCase());
            if (existingPlayer) {
                if (level > existingPlayer.level) existingPlayer.level = level;
                existingPlayer.lastPlayed = new Date().toISOString();
            } else {
                gameData.players.push({ name: playerName, level: level, lastPlayed: new Date().toISOString() });
            }
            gameData.players.sort((a, b) => b.level - a.level);
            
            // Salva in localStorage (fallback se JSONBIN non disponibile)
            localStorage.setItem('metaverseLeaderboard', JSON.stringify(gameData));
            
            // Carica eventualmente da localStorage se assente
            if (!localStorage.getItem('metaverseLeaderboard')) {
                localStorage.setItem('metaverseLeaderboard', JSON.stringify(gameData));
            }
        }

        function loadLeaderboard() {
            const saved = localStorage.getItem('metaverseLeaderboard');
            if (saved) {
                try {
                    gameData = JSON.parse(saved);
                } catch (e) {
                    console.error('Errore caricamento dati:', e);
                }
            }
        }

        window.showLeaderboard = function() {
            loadLeaderboard();
            const list = document.getElementById('leaderboard-list');
            list.innerHTML = '';
            gameData.players.slice(0, 20).forEach((player, idx) => {
                const entry = document.createElement('div');
                entry.className = 'leaderboard-entry';
                entry.innerHTML = `<span class="rank">#${idx + 1}</span><span class="name">${player.name}</span><span class="score">LV. ${player.level}</span>`;
                list.appendChild(entry);
            });
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('leaderboard-screen').style.display = 'flex';
        };

        window.backToLogin = function() {
            document.getElementById('leaderboard-screen').style.display = 'none';
            document.getElementById('login-screen').style.display = 'flex';
        };

        window.initializeGame = function() {
            const username = document.getElementById('login-username').value.trim();
            if (!username) {
                alert('Inserisci un nome valido');
                return;
            }
            window.currentPlayer = username;
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('player-name-display').textContent = `Benvenuto, ${username}!`;
            loadLeaderboard();
        };

        window.startGameSession = function() {
            document.getElementById('start-screen').classList.add('hidden');
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                document.getElementById('mobile-controls').classList.add('active');
                document.getElementById('jump-btn').classList.add('active');
                state.isPlaying = true;
                if (audioCtx.state === 'suspended') audioCtx.resume();
                sound.isPlaying = true;
                initMobileControls();
            } else {
                controls.lock();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                sound.isPlaying = true;
            }
        };

        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        class SoundEngine {
            constructor() {
                this.gainNode = audioCtx.createGain();
                this.gainNode.gain.value = 0.12;
                this.gainNode.connect(audioCtx.destination);
                this.isPlaying = false;
                this.timer = 0;
            }

            playJump() {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.connect(gain);
                    gain.connect(this.gainNode);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                } catch (e) {}
            }

            playLevelUp() {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                    osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.connect(gain);
                    gain.connect(this.gainNode);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.5);
                } catch (e) {}
            }

            playDeath() {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                    osc.connect(gain);
                    gain.connect(this.gainNode);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                } catch (e) {}
            }

            update(time) {
                if(!this.isPlaying) return;
                if (time - this.timer > 0.25) {
                    this.timer = time;
                    this.playBassNote(time);
                }
            }

            playBassNote(time) {
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sawtooth';
                    const notes = [65.41, 77.78, 98.00, 77.78];
                    const note = notes[Math.floor(time * 4) % 4];
                    osc.frequency.value = note;
                    
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = "lowpass";
                    filter.frequency.setValueAtTime(200, audioCtx.currentTime);
                    filter.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                    filter.frequency.linearRampToValueAtTime(200, audioCtx.currentTime + 0.2);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.gainNode);
                    
                    gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);

                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.22);
                } catch (e) {}
            }
        }

        const sound = new SoundEngine();

        // --- MOBILE CONTROLS ---
        let mobileInput = { x: 0, y: 0, jumping: false };
        let touchStartX = 0, touchStartY = 0;
        
        function initMobileControls() {
            const joystick = document.getElementById('mobile-controls');
            const stick = document.getElementById('joystick-stick');
            const jumpBtn = document.getElementById('jump-btn');
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const maxDist = rect.width / 2 - 30;
                
                if (dist > maxDist) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxDist;
                    dy = Math.sin(angle) * maxDist;
                }
                
                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                mobileInput.x = dx / maxDist;
                mobileInput.y = dy / maxDist;
            });
            
            joystick.addEventListener('touchend', () => {
                stick.style.transform = 'translate(-50%, -50%)';
                mobileInput.x = 0;
                mobileInput.y = 0;
            });
            
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (state.canJump && !state.isDying) {
                    state.velocity.y = config.jumpForce;
                    state.canJump = false;
                    sound.playJump();
                }
            });
        }

        // --- CONFIG & STATE ---
        const config = {
            maxLevels: 100,
            speed: 11.0,
            jumpForce: 16.0,
            gravity: 42.0,
            eyeHeight: 1.6,
            collisionTolerance: 0.5
        };

        const state = {
            level: 1,
            isPlaying: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            canJump: false,
            movingPlatformVelocity: new THREE.Vector3(),
            platformVelocity: new THREE.Vector3(),
            lastPlatformPos: new THREE.Vector3(),
            isDying: false,
            isMobile: false
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.018);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.3, 0.35, 0.8);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.25;
        composer.addPass(bloomPass);

        // --- LIGHTING ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.15);
        scene.add(hemiLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 60);
        scene.add(pointLight);

        // --- CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const startScreen = document.getElementById('start-screen');

        controls.addEventListener('lock', () => {
            startScreen.classList.add('hidden');
            state.isPlaying = true;
        });

        controls.addEventListener('unlock', () => {
            startScreen.classList.remove('hidden');
            state.isPlaying = false;
            sound.isPlaying = false;
        });

        // --- GAMEPLAY OBJECTS ---
        let platforms = [];
        let movingPlatforms = [];
        let activeLights = [];
        let portal;
        let particles;
        const platformGeo = new THREE.BoxGeometry(1, 1, 1);
        const platformMat = new THREE.MeshStandardMaterial({
            color: 0x111111, roughness: 0.15, metalness: 0.9,
            emissive: 0x00ffff, emissiveIntensity: 0.4
        });

        const gridHelper = new THREE.GridHelper(250, 125, 0xff00ff, 0x220033);
        gridHelper.position.y = -25;
        scene.add(gridHelper);

        function getLevelColor(level) {
            const hue = (level * 32) % 360;
            return new THREE.Color(`hsl(${hue}, 100%, 50%)`);
        }

        function createPlatform(x, y, z, w, d, type = 'static') {
            const mesh = new THREE.Mesh(platformGeo, platformMat.clone());
            mesh.scale.set(w, 1, d);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1));
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }));
            mesh.add(line);

            mesh.userData = {
                type: type,
                originalY: y,
                phase: Math.random() * Math.PI * 2,
                width: w,
                depth: d,
                lastPos: new THREE.Vector3(x, y, z)
            };
            
            scene.add(mesh);
            platforms.push(mesh);
            if (type === 'moving') movingPlatforms.push(mesh);
            return mesh;
        }

        function cleanupLevel() {
            platforms.forEach(p => {
                p.geometry.dispose();
                p.material.dispose();
                scene.remove(p);
            });
            movingPlatforms = [];
            platforms = [];
            
            if(portal) {
                portal.geometry.dispose();
                portal.material.dispose();
                scene.remove(portal);
                portal = null;
            }
            if(particles) {
                particles.geometry.dispose();
                particles.material.dispose();
                scene.remove(particles);
                particles = null;
            }
            
            activeLights.forEach(light => scene.remove(light));
            activeLights = [];
        }

        function generateLevel(levelIndex) {
            cleanupLevel();

            state.velocity.set(0,0,0);
            state.movingPlatformVelocity.set(0,0,0);
            camera.position.set(0, 5, 0);

            document.getElementById('level-val').innerText = `${String(levelIndex).padStart(2, '0')} / 100`;
            document.getElementById('player-val').innerText = (window.currentPlayer || 'UNKNOWN').substring(0, 10).toUpperCase();
            
            const mainColor = getLevelColor(levelIndex);
            document.documentElement.style.setProperty('--neon-color', '#' + mainColor.getHexString());
            scene.fog.color = new THREE.Color(0x050510).lerp(mainColor, 0.04);
            gridHelper.material.color = mainColor;

            // Piattaforma iniziale
            createPlatform(0, -1, 0, 10, 10);

            let cx = 0, cy = 0, cz = 0;
            const baseSegments = 4 + Math.floor(levelIndex * 0.6);
            const segments = Math.min(baseSegments, 25);
            const platformSizeVariance = 0.3 + (levelIndex * 0.02);
            
            for(let i=0; i<segments; i++) {
                const rand = Math.random();
                const scaledDist = 5.5 + (levelIndex * 0.08);
                const platformSize = 4 + platformSizeVariance;
                
                if (rand < 0.15 && levelIndex > 8) {
                    // Piattaforma Mobile
                    cz -= scaledDist + 3;
                    createPlatform(cx, cy, cz, platformSize - 0.5, platformSize - 0.5, 'moving');
                    cz -= scaledDist + 3;
                } else if (rand < 0.4) {
                    // Scale
                    const steps = 2 + Math.floor(levelIndex * 0.05);
                    for(let s=0; s<steps; s++) {
                        cz -= 4.5;
                        cy += 1.8;
                        createPlatform(cx, cy, cz, platformSize, platformSize);
                    }
                } else if (rand < 0.65) {
                    // Zig Zag
                    cz -= scaledDist;
                    cx += (Math.random() > 0.5 ? 7 : -7);
                    createPlatform(cx, cy, cz, platformSize, platformSize);
                } else {
                    // Salto Diritto
                    cz -= scaledDist;
                    const yShift = (Math.random() - 0.35) * 2.5;
                    cy += yShift;
                    createPlatform(cx, cy, cz, platformSize, platformSize);
                }
            }

            // Portal
            createPortal(cx, cy + 2.5, cz - 5, mainColor);
        }

        function createPortal(x, y, z, color) {
            const geo = new THREE.TorusKnotGeometry(1.2, 0.35, 100, 16);
            const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: false });
            portal = new THREE.Mesh(geo, mat);
            portal.position.set(x, y, z);
            scene.add(portal);

            const pGeo = new THREE.BufferGeometry();
            const pCount = 150;
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random() - 0.5) * 4;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: color, size: 0.08, blending: THREE.AdditiveBlending });
            particles = new THREE.Points(pGeo, pMat);
            portal.add(particles);
            
            const light = new THREE.PointLight(color, 2.5, 20);
            light.position.set(x, y, z);
            scene.add(light);
            activeLights.push(light);
        }

        // --- INPUT HANDLING ---
        const move = { f: false, b: false, l: false, r: false };
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': move.f = true; break;
                case 'KeyS': move.b = true; break;
                case 'KeyA': move.l = true; break;
                case 'KeyD': move.r = true; break;
                case 'Space':
                    if(state.canJump && !state.isDying) {
                        state.velocity.y = config.jumpForce;
                        state.canJump = false;
                        sound.playJump();
                    }
                    break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': move.f = false; break;
                case 'KeyS': move.b = false; break;
                case 'KeyA': move.l = false; break;
                case 'KeyD': move.r = false; break;
            }
        });

        // --- GAME LOOP ---
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const forwardVector = new THREE.Vector3(0, 0, -1);
        const rightVector = new THREE.Vector3(1, 0, 0);
        let frames = 0, lastTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.016);
            const time = clock.getElapsedTime();

            frames++;
            if (time - lastTime >= 1) {
                document.getElementById('fps-val').innerText = Math.round(frames);
                frames = 0;
                lastTime = time;
            }

            if (state.isPlaying && !state.isDying) {
                sound.update(time);

                // --- ANIMATE MOVING PLATFORMS ---
                movingPlatforms.forEach(p => {
                    const oldY = p.position.y;
                    p.position.x += Math.sin(time * 2.5 + p.userData.phase) * 0.04;
                    p.position.y = p.userData.originalY + Math.sin(time * 1.2 + p.userData.phase) * 1.2;
                    p.position.z += Math.cos(time * 1.8 + p.userData.phase) * 0.03;
                    
                    p.material.emissiveIntensity = 0.4 + Math.sin(time * 4 + p.userData.phase) * 0.25;
                });
                
                gridHelper.position.z = camera.position.z;
                gridHelper.position.x = camera.position.x;

                if(portal) {
                    portal.rotation.x += 0.01;
                    portal.rotation.y += 0.008;
                    if(particles) particles.rotation.y -= 0.012;
                }

                // --- PHYSICS ---
                state.velocity.x *= (1 - 4.5 * dt);
                state.velocity.z *= (1 - 4.5 * dt);
                state.velocity.y -= config.gravity * dt;

                state.direction.z = Number(move.f) - Number(move.b) + (state.isMobile ? mobileInput.y : 0);
                state.direction.x = Number(move.r) - Number(move.l) + (state.isMobile ? mobileInput.x : 0);
                if (state.direction.length() > 0) state.direction.normalize();

                const accel = 18;
                if (move.f || move.b || (state.isMobile && Math.abs(mobileInput.y) > 0.1)) state.velocity.z -= state.direction.z * config.speed * accel * dt;
                if (move.l || move.r || (state.isMobile && Math.abs(mobileInput.x) > 0.1)) state.velocity.x -= state.direction.x * config.speed * accel * dt;

                controls.moveRight(-state.velocity.x * dt);
                controls.moveForward(-state.velocity.z * dt);
                controls.getObject().position.addScaledVector(state.movingPlatformVelocity, dt);
                state.movingPlatformVelocity.set(0,0,0);
                controls.getObject().position.y += state.velocity.y * dt;

                // --- MULTI-DIRECTIONAL COLLISION ---
                const origin = controls.getObject().position.clone();
                const checkPoints = [
                    { ray: downVector, offset: new THREE.Vector3(0, -config.eyeHeight - 0.1, 0) },
                    { ray: forwardVector, offset: new THREE.Vector3(0, 0, -0.4) },
                    { ray: new THREE.Vector3(-forwardVector.x, 0, -forwardVector.z), offset: new THREE.Vector3(0, 0, 0.4) },
                    { ray: rightVector, offset: new THREE.Vector3(0.4, 0, 0) },
                    { ray: new THREE.Vector3(-rightVector.x, 0, 0), offset: new THREE.Vector3(-0.4, 0, 0) }
                ];

                let onGround = false;
                let currentPlatform = null;

                checkPoints.forEach(check => {
                    raycaster.ray.origin.copy(origin).add(check.offset);
                    raycaster.ray.direction = check.ray;
                    const intersects = raycaster.intersectObjects(platforms, false);
                    
                    if (intersects.length > 0 && intersects[0].distance < (check.ray.equals(downVector) ? config.collisionTolerance : 0.6)) {
                        if (check.ray.equals(downVector)) {
                            onGround = true;
                            currentPlatform = intersects[0].object;
                            state.velocity.y = Math.max(0, state.velocity.y);
                            state.canJump = true;
                            controls.getObject().position.y = intersects[0].point.y + config.eyeHeight;
                        } else {
                            // Collision laterale
                            state.velocity[check.ray.x !== 0 ? 'x' : 'z'] *= 0.3;
                        }
                    }
                });

                // --- MOVING PLATFORM VELOCITY INHERITANCE ---
                if (currentPlatform && currentPlatform.userData.type === 'moving') {
                    const lastPos = currentPlatform.userData.lastPos;
                    state.movingPlatformVelocity.copy(currentPlatform.position).sub(lastPos).multiplyScalar(1/dt);
                    currentPlatform.userData.lastPos.copy(currentPlatform.position);
                }

                pointLight.position.copy(camera.position);

                // --- CHECK FALL ---
                if (camera.position.y < -35) {
                    triggerDeath();
                }

                // --- CHECK WIN ---
                if(portal && camera.position.distanceTo(portal.position) < 2.5) {
                    sound.playLevelUp();
                    state.level++;
                    if(state.level > config.maxLevels) {
                        state.level = 1;
                        saveScore(window.currentPlayer, 100);
                    } else {
                        saveScore(window.currentPlayer, state.level);
                    }
                    generateLevel(state.level);
                }
            }

            composer.render();
        }

        function triggerDeath() {
            if (state.isDying) return;
            state.isDying = true;
            sound.playDeath();
            const overlay = document.getElementById('death-overlay');
            overlay.style.display = 'block';
            setTimeout(() => {
                overlay.style.display = 'none';
                state.isDying = false;
                generateLevel(state.level);
            }, 1200);
        }

        // --- RESPONSIVE ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- INIT ---
        const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        state.isMobile = isMobileDevice;
        
        if (isMobileDevice) {
            document.getElementById('controls-info-text').innerHTML = 'ðŸ‘† JOYSTICK MUOVITI &nbsp;|&nbsp; â­• SALTA &nbsp;|&nbsp; GYRO GUARDA<br>Raggiungi il PORTALE per caricare il prossimo settore.';
        }
        
        // Gyroscope Support
        if (isMobileDevice && window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (event) => {
                if (!state.isPlaying || state.isMobile) return;
                const alpha = event.alpha || 0;
                const beta = event.beta || 0;
                const gamma = event.gamma || 0;
                
                // Applica rotazione camera
                const multiplier = 0.02;
                controls.getObject().rotation.y -= (gamma - 0) * multiplier;
                controls.getObject().rotation.x -= (beta - 50) * multiplier * 0.5;
            }, false);
        }
        
        loadLeaderboard();
        generateLevel(1);
        animate();
    </script>
</body>
</html>
