<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#050510">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>METAVERSE STAIRWAY</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <script type="text/javascript" src="https://gc.kis.v2.scr.kaspersky-labs.com/FD126C42-EBFA-4E12-B309-BB3FDD723AC1/main.js?attr=Ic7wQjIsmIcubhjH1JFBT_OY5ahOVVjse2GWBN-XBGmmsGy9cBj1PMqy-jL84INm_hQBoQYeAPpaAl7-4QjEHdN_Qa3Bd2isJZlaHGQqHnd_9Lx6bi7ysKRLAoRPVpboXgeUqGBZnSilI4g2bohFNzC7sH-ATpq-4BRMjFKF7O9MKTOQMFFZ1T5pAvqXSyAZaejPkP-nZmU2qkQqIqiulNzlb_cqGIErB_V6QtZ4B72tDP1kmOZh-b1WI4b7b9Bdx0SlODX_WgiOSfKM8MuyU_ubnzsW5gsaBTMj3vMoRSSQyaYistcHEPfFg6p-xqHggw5tybNNPpSQN-5HbXH4v-hzD1is6VpD6lb8iczvX5Am7333BQhSqv19107hD_gcSx19VOlnOzRuFpLukttDpahyWqedtsXXWhdP15vRdMJhcWaivAO854iFT5vqIw0KllK8w16m2W_NeVdUP-dMiqv45nspsmJYaURxfEqwQDdmGndrTJjoj6eFo9d3stn-KoNSD5sxcd-FQKxSEldxHeOVc-uMFWSRt_QhKAaH76rrnwyCGOdMS1WvZf5zd1XKbAKVoka7E6ovH-fa5fuhZC3qNvfGGltpP8f_U9PXoPLKHCrrlt_ySKqOYVQpDUcA3eanQCjSkmuqmUGbF8tNhDmALe73YM18n3wtSkZ6OMtwYVhEt1-HE2pfkfZLGfHgxEgo10TtYN_Ka3krO4CM0L1nfgF09MrRsPlr0Ocb6PGh5cSrBdl6JgIwlnM8eh0XTJajv0RCwoggYOOcSmC5eZRGd15kfESU66Caht9Oe6XbuDidEb5-kWZSVWnO_Y3FFukOmeSzi_AzrDcRfjzvToX_uJUgU-zQN5cPMwzxNw-MBMFmhUg8k3LlBxNQ3nvEYaopkVa3LPz9ZYfQ7NIfgwWceHwqRKHzbOI59KLoeofuO766rvhDKc3RkX2RMR0umqioxpVju7LKeq6buoUGz3ahdtqCb6rBBrlJ0I3EY0wNOzRjStLhoVHH7RbCduRYhU88TogS5KqjSVIgYJmh3_uEvB-SKD3rpPR0tUiUmOXWiDy_3hKFxb5uMvC95cGzwP_Qs9JO9fKme2gg71R29_bXRzcTDPKmY3e9ewcOmtQYcU6iZU0rEjnHmmyiTBLUj_6Y8JJCt1r7-0Nm4h59oxlOCTP1UzSa7rKE0dkdmm-i_ZTocAQtA3g5BwLbT8grgLT05uKFKYcCoDUcvmSbaMDedFvD_Yehph-EIPb8KA_smVln435JKkK5sqQFghxisJVRpW1IZfd4YC9EruseJLkQ2vblN9HtB_zGIukoWVGKmeVCWYuoc8YdSpgI3PTL7g90kFK8zh9TXSriu4hMqGP6gYzaqrEDEVbY5J5xGXwhdxNl_8YtqtEvz2bHyScbCglsyP9PllbkMlnobwi2c_ZoZObAinF6Hr8vGduynkP-JBFuIm6m29CNhyrrR3jI4LB1o48FRa-9btcMCWork4yD6RkX9abG20FQl-MDK9CpdsLGZtMbrK4o3WmeWdiVzBxn7_O6agfnktAcBe4bkML3Xx28ZlQly0yvQAaKrFEtq8fn97srG6MY07twNZoE6ME0COOoI3SEsxDuO-KQbAERHKLag5lUOnlR_gTqh50ztuEyFDJcaKPzGXPZVXPO08FblZ6lA-0gnDAGkZ-xUILxsLwAw4QUDjmQSIS91M0dDoNteB_p7Gz-h-ELrA8P-ROfKsG9-93UiFyn8Qj0y_xkJs-CwNQOJCe0ToZsMmoKSU1zOqzk8wjX56RCiVeqSCIihUu_8yIoA_ErpGUovuuCnfGZ5Q-82aA072M8LWjbKHbavnoF7mLWSesh8LZsHS6GLYA-ppY6724d-UEArX0PPFe0yvCkBdNrN-5WnAfUiMAFA-GxywUOGvLag0udO4vfMBjsGxIcSbvSxnDH8t9N8mSipwrEBvxDli3E8H9iJhBXYW24Uz8cSI2J2qMRTLMaTeIJuOA-MeisJ1CEkJPkEsic0rYmqb97sb4vaNM2IrVgMPJL56J80tcfJv9Q1IDIK0SnvT8HPPTAinLImE1NfInPjUVm-EuWrSpwoFOiPRdLV2s7UTdhWWcC5Dl2nt3NJP8Axt5nGmJjbyTF2Zoq5JxfYMdbf6azZfYeaBZ8up_Ow0zYhH6w6UPohKQBBZ6o5KS9NtgOYCXnX9xXkf4NF_fnSgm2xIng-CGmyCz4_2VvCW4doFK_LN0QN9Ch" charset="UTF-8"></script><style>
        :root { 
            --neon-color: #00f3ff; 
            --bg-color: #050510; 
            --neon-pink: #ff00ff;
            --neon-yellow: #ffff00;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            margin: 0; 
            overflow: hidden; 
            background-color: var(--bg-color);
            font-family: 'Orbitron', sans-serif; 
            user-select: none;
        }
        
        body::after {
            content: " "; 
            display: block; 
            position: absolute; 
            top: 0; 
            left: 0; 
            bottom: 0; 
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 100; 
            background-size: 100% 2px, 3px 100%; 
            pointer-events: none;
        }

        #login-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
            backdrop-filter: blur(10px);
        }

        #login-screen.hidden {
            display: none;
        }

        .login-container {
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .login-title {
            font-size: 60px;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 20px var(--neon-color), 0 0 40px var(--neon-color);
            margin-bottom: 10px;
            letter-spacing: 3px;
        }

        .login-subtitle {
            font-size: 20px;
            color: var(--neon-pink);
            margin-bottom: 50px;
            text-shadow: 0 0 10px var(--neon-pink);
        }

        .login-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .login-input {
            padding: 14px 20px;
            font-size: 16px;
            background: rgba(0, 243, 255, 0.05);
            border: 2px solid var(--neon-color);
            color: var(--neon-color);
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            border-radius: 8px;
            outline: none;
            transition: all 0.3s;
        }

        .login-input:focus {
            box-shadow: 0 0 20px var(--neon-color);
            background: rgba(0, 243, 255, 0.15);
            border-color: var(--neon-yellow);
        }

        .login-input::placeholder {
            color: rgba(0, 243, 255, 0.5);
        }

        .login-btn {
            padding: 15px 40px;
            font-size: 18px;
            background: transparent;
            color: var(--neon-color);
            border: 2px solid var(--neon-color);
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--neon-color);
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 8px;
            margin-top: 20px;
        }

        .login-btn:hover {
            background: var(--neon-color);
            color: black;
            box-shadow: 0 0 40px var(--neon-color);
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: none;
        }

        #game-container.active {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 30px;
            text-shadow: 0 0 10px var(--neon-color);
            color: white;
        }

        .hud-box {
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            transform: skewX(-15deg);
            border-radius: 4px;
        }

        .hud-label {
            font-size: 12px;
            color: #aaa;
            display: block;
        }

        .hud-value {
            font-size: 24px;
            font-weight: 900;
            color: var(--neon-color);
        }

        #hud-bottom {
            position: fixed;
            bottom: 30px;
            left: 30px;
            display: flex;
            gap: 20px;
            z-index: 10;
            pointer-events: auto;
        }

        .hud-box-bottom {
            border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            color: white;
        }

        .hud-label-bottom {
            font-size: 10px;
            color: #aaa;
            display: block;
        }

        .hud-value-bottom {
            font-size: 20px;
            font-weight: 900;
            color: var(--neon-color);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: var(--neon-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px var(--neon-color);
            z-index: 20;
        }

        #level-word {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%) rotateZ(-90deg) translateY(-50px);
            font-size: 48px;
            font-weight: 900;
            color: var(--neon-color);
            text-shadow: 0 0 20px var(--neon-color);
            letter-spacing: 2px;
            z-index: 15;
            opacity: 0;
            transition: opacity 0.5s, color 0.3s;
        }

        #level-word.active {
            opacity: 1;
        }

        #death-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            display: none;
            z-index: 150;
            animation: deathFlash 0.2s ease-out;
        }

        @keyframes deathFlash {
            from { background: rgba(255, 0, 0, 0.8); }
            to { background: rgba(255, 0, 0, 0.3); }
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            backdrop-filter: blur(5px);
            pointer-events: auto;
            text-align: center;
        }

        #start-screen.hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        h1 {
            font-size: 60px;
            color: white;
            text-shadow: 0 0 20px var(--neon-color);
            margin: 0;
            letter-spacing: 5px;
        }

        h1 span {
            font-size: 30px;
            color: var(--neon-pink);
        }

        .controls-info {
            margin-top: 20px;
            color: #888;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 40px;
        }

        .btn-start {
            padding: 15px 50px;
            font-size: 20px;
            background: transparent;
            color: var(--neon-color);
            border: 2px solid var(--neon-color);
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: 0.3s;
            box-shadow: 0 0 15px var(--neon-color);
            text-transform: uppercase;
            font-weight: bold;
            border-radius: 8px;
        }

        .btn-start:hover {
            background: var(--neon-color);
            color: black;
            box-shadow: 0 0 40px var(--neon-color);
        }

        @media (max-width: 768px) {
            .login-title { font-size: 40px; }
            .login-input { font-size: 14px; padding: 12px 15px; }
            .login-btn { padding: 12px 30px; font-size: 16px; }
            h1 { font-size: 40px; }
            h1 span { font-size: 20px; }
            .hud-box { padding: 8px 15px; }
            .hud-value { font-size: 18px; }
            #level-word { font-size: 32px; }
        }

        @media (max-width: 480px) {
            .login-title { font-size: 28px; letter-spacing: 2px; }
            .login-input { font-size: 13px; padding: 10px 12px; }
            .login-btn { padding: 10px 25px; font-size: 14px; }
            h1 { font-size: 28px; }
            h1 span { font-size: 16px; }
            .hud-box { padding: 6px 10px; }
            .hud-value { font-size: 14px; }
            #level-word { font-size: 20px; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="login-screen">
        <div class="login-container">
            <div class="login-title">METAVERSE<br><span>STAIRWAY</span></div>
            <div class="login-subtitle">Scala verso l'infinito</div>
            <form class="login-form" onsubmit="handleLogin(event)">
                <input type="text" class="login-input" id="username-input" placeholder="Inserisci il tuo nome" maxlength="20" required autofocus>
                <button type="submit" class="login-btn">ACCEDI</button>
            </form>
        </div>
    </div>

    <div id="game-container">
        <div id="death-overlay"></div>

        <div id="ui-layer">
            <div id="hud-top">
                <div class="hud-box">
                    <span class="hud-label">GIOCATORE</span>
                    <span class="hud-value" id="player-val">---</span>
                </div>
                <div class="hud-box">
                    <span class="hud-label">LEVEL</span>
                    <span class="hud-value" id="level-val">01 / 100</span>
                </div>
                <div class="hud-box">
                    <span class="hud-label">FPS</span>
                    <span class="hud-value" id="fps-val">60</span>
                </div>
            </div>

            <div id="hud-bottom">
                <div class="hud-box-bottom">
                    <span class="hud-label-bottom">VITE</span>
                    <span class="hud-value-bottom" id="lives-val">100</span>
                </div>
                <div class="hud-box-bottom">
                    <span class="hud-label-bottom">RANK</span>
                    <span class="hud-value-bottom" id="rank-val">#--</span>
                </div>
            </div>

            <div id="crosshair"></div>
            <div id="level-word"></div>
        </div>

        <div id="start-screen">
            <h1>METAVERSE<br><span>STAIRWAY</span></h1>
            <p id="player-name-display" style="color: var(--neon-color); margin: 20px 0; font-size: 18px;"></p>
            <p class="controls-info">
                [WASD] MUOVITI | [SPACE] SALTA | [MOUSE] GUARDA<br>
                Raggiungi il PORTALE per caricare il prossimo settore.
            </p>
            <button class="btn-start" onclick="startGameSession()">INIZIA SESSIONE</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let window_currentPlayer = "";

        const levelWords = [
            'alba', 'tros', 'pros', 'gross', 'frto',
            'frtg', 'hyt', 'rdedff', 'eddfr', 'tgfder'
        ];

        function getWordForLevel(levelIndex) {
            const wordIndex = Math.floor((levelIndex - 1) / 10);
            return levelWords[wordIndex] || levelWords[levelWords.length - 1];
        }

        function getLevelColor(level) {
            const hue = (level * 32) % 360;
            return new THREE.Color(`hsl(${hue}, 100%, 50%)`);
        }

        window.handleLogin = function(event) {
            event.preventDefault();
            const username = document.getElementById('username-input').value.trim();
            
            if (username.length < 3 || username.length > 20) {
                alert('Nome deve essere tra 3 e 20 caratteri');
                return;
            }

            window_currentPlayer = username;
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('game-container').classList.add('active');
            document.getElementById('player-name-display').textContent = `Benvenuto, ${window_currentPlayer}!`;
            
            setTimeout(() => initGame(), 500);
        };

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const gainNode = audioCtx.createGain();
        gainNode.gain.value = 0.12;
        gainNode.connect(audioCtx.destination);

        function playJump() {
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(gainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } catch (e) {}
        }

        function playLevelUp() {
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                osc.frequency.exponentialRampToValueAtTime(1760, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(gainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) {}
        }

        function playDeath() {
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(gainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            } catch (e) {}
        }

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.018);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.3, 0.35, 0.8);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.25;
        composer.addPass(bloomPass);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.15);
        scene.add(hemiLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 60);
        scene.add(pointLight);

        const controls = new PointerLockControls(camera, document.body);

        const state = {
            level: 1,
            lives: 100,
            isPlaying: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            canJump: false,
            movingPlatformVelocity: new THREE.Vector3(),
            isDying: false
        };

        const config = {
            maxLevels: 100,
            speed: 11.0,
            jumpForce: 16.0,
            gravity: 42.0,
            eyeHeight: 1.6,
            collisionTolerance: 0.5
        };

        let platforms = [];
        let movingPlatforms = [];
        let portal;
        let particles;

        const platformGeo = new THREE.BoxGeometry(1, 1, 1);
        const platformMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.15,
            metalness: 0.9,
            emissive: 0x00ffff,
            emissiveIntensity: 0.4
        });

        const gridHelper = new THREE.GridHelper(250, 125, 0xff00ff, 0x220033);
        gridHelper.position.y = -25;
        scene.add(gridHelper);

        function createPlatform(x, y, z, w, d, type = 'static') {
            const mesh = new THREE.Mesh(platformGeo, platformMat.clone());
            mesh.scale.set(w, 1, d);
            mesh.position.set(x, y, z);

            const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1));
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 }));
            mesh.add(line);

            mesh.userData = {
                type: type,
                originalY: y,
                phase: Math.random() * Math.PI * 2,
                width: w,
                depth: d,
                lastPos: new THREE.Vector3(x, y, z)
            };

            scene.add(mesh);
            platforms.push(mesh);
            if (type === 'moving') movingPlatforms.push(mesh);
            return mesh;
        }

        function cleanupLevel() {
            platforms.forEach(p => {
                p.geometry.dispose();
                p.material.dispose();
                scene.remove(p);
            });
            movingPlatforms = [];
            platforms = [];

            if (portal) {
                portal.geometry.dispose();
                portal.material.dispose();
                scene.remove(portal);
                portal = null;
            }
        }

        function generateLevel(levelIndex) {
            cleanupLevel();

            state.velocity.set(0, 0, 0);
            state.movingPlatformVelocity.set(0, 0, 0);
            camera.position.set(0, 1.6, 0);
            controls.getObject().position.set(0, 1.6, 0);

            document.getElementById('level-val').innerText = `${String(levelIndex).padStart(2, '0')} / 100`;
            document.getElementById('player-val').innerText = window_currentPlayer.substring(0, 10).toUpperCase();
            document.getElementById('lives-val').innerText = state.lives;

            const mainColor = getLevelColor(levelIndex);
            const hexColor = '#' + mainColor.getHexString();
            document.documentElement.style.setProperty('--neon-color', hexColor);
            scene.fog.color = new THREE.Color(0x050510).lerp(mainColor, 0.04);
            gridHelper.material.color = mainColor;

            const word = getWordForLevel(levelIndex);
            const wordDisplay = document.getElementById('level-word');
            wordDisplay.textContent = word;
            wordDisplay.style.color = hexColor;
            wordDisplay.classList.add('active');

            createPlatform(0, -0.5, 0, 12, 12);

            let cx = 0, cy = 0, cz = 0;
            const baseSegments = 4 + Math.floor(levelIndex * 0.6);
            const segments = Math.min(baseSegments, 25);

            for (let i = 0; i < segments; i++) {
                const rand = Math.random();
                const scaledDist = 5.5 + (levelIndex * 0.08);
                const platformSize = 4;

                if (rand < 0.15 && levelIndex > 8) {
                    cz -= scaledDist + 3;
                    createPlatform(cx, cy, cz, platformSize - 0.5, platformSize - 0.5, 'moving');
                    cz -= scaledDist + 3;
                } else if (rand < 0.4) {
                    const steps = 2 + Math.floor(levelIndex * 0.05);
                    for (let s = 0; s < steps; s++) {
                        cz -= 4.5;
                        cy += 1.8;
                        createPlatform(cx, cy, cz, platformSize, platformSize);
                    }
                } else if (rand < 0.65) {
                    cz -= scaledDist;
                    cx += (Math.random() > 0.5 ? 7 : -7);
                    createPlatform(cx, cy, cz, platformSize, platformSize);
                } else {
                    cz -= scaledDist;
                    const yShift = (Math.random() - 0.35) * 2.5;
                    cy += yShift;
                    createPlatform(cx, cy, cz, platformSize, platformSize);
                }
            }

            const portalGeo = new THREE.TorusKnotGeometry(1.2, 0.35, 100, 16);
            const portalMat = new THREE.MeshBasicMaterial({ color: mainColor });
            portal = new THREE.Mesh(portalGeo, portalMat);
            portal.position.set(cx, cy + 2.5, cz - 5);
            scene.add(portal);

            const pGeo = new THREE.BufferGeometry();
            const pCount = 150;
            const pPos = new Float32Array(pCount * 3);
            for (let i = 0; i < pCount * 3; i++) pPos[i] = (Math.random() - 0.5) * 4;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: mainColor, size: 0.08, blending: THREE.AdditiveBlending });
            particles = new THREE.Points(pGeo, pMat);
            portal.add(particles);
        }

        const move = { f: false, b: false, l: false, r: false };

        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': move.f = true; break;
                case 'KeyS': move.b = true; break;
                case 'KeyA': move.l = true; break;
                case 'KeyD': move.r = true; break;
                case 'Space':
                    if (state.canJump && !state.isDying) {
                        state.velocity.y = config.jumpForce;
                        state.canJump = false;
                        playJump();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': move.f = false; break;
                case 'KeyS': move.b = false; break;
                case 'KeyA': move.l = false; break;
                case 'KeyD': move.r = false; break;
            }
        });

        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const downVector = new THREE.Vector3(0, -1, 0);
        const forwardVector = new THREE.Vector3(0, 0, -1);
        const rightVector = new THREE.Vector3(1, 0, 0);
        let frames = 0, lastTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.016);
            const time = clock.getElapsedTime();

            frames++;
            if (time - lastTime >= 1) {
                document.getElementById('fps-val').innerText = Math.round(frames);
                frames = 0;
                lastTime = time;
            }

            if (state.isPlaying && !state.isDying) {
                movingPlatforms.forEach(p => {
                    p.position.x += Math.sin(time * 2.5 + p.userData.phase) * 0.04;
                    p.position.y = p.userData.originalY + Math.sin(time * 1.2 + p.userData.phase) * 1.2;
                    p.position.z += Math.cos(time * 1.8 + p.userData.phase) * 0.03;
                    p.material.emissiveIntensity = 0.4 + Math.sin(time * 4 + p.userData.phase) * 0.25;
                });

                gridHelper.position.z = camera.position.z;
                gridHelper.position.x = camera.position.x;

                if (portal) {
                    portal.rotation.x += 0.01;
                    portal.rotation.y += 0.008;
                    if (particles) particles.rotation.y -= 0.012;
                }

                state.velocity.x *= (1 - 4.5 * dt);
                state.velocity.z *= (1 - 4.5 * dt);
                state.velocity.y -= config.gravity * dt;

                state.direction.z = Number(move.f) - Number(move.b);
                state.direction.x = Number(move.r) - Number(move.l);
                if (state.direction.length() > 0) state.direction.normalize();

                const accel = 9;
                if (move.f || move.b) state.velocity.z -= state.direction.z * config.speed * accel * dt;
                if (move.l || move.r) state.velocity.x -= state.direction.x * config.speed * accel * dt;

                controls.moveRight(-state.velocity.x * dt);
                controls.moveForward(-state.velocity.z * dt);
                controls.getObject().position.addScaledVector(state.movingPlatformVelocity, dt);
                state.movingPlatformVelocity.set(0, 0, 0);
                controls.getObject().position.y += state.velocity.y * dt;

                const origin = controls.getObject().position.clone();
                const checkPoints = [
                    { ray: downVector, offset: new THREE.Vector3(0, -config.eyeHeight - 0.1, 0) },
                    { ray: forwardVector, offset: new THREE.Vector3(0, 0, -0.4) },
                    { ray: rightVector, offset: new THREE.Vector3(0.4, 0, 0) },
                    { ray: new THREE.Vector3(-rightVector.x, 0, 0), offset: new THREE.Vector3(-0.4, 0, 0) }
                ];

                let currentPlatform = null;

                checkPoints.forEach(check => {
                    raycaster.ray.origin.copy(origin).add(check.offset);
                    raycaster.ray.direction = check.ray;
                    const intersects = raycaster.intersectObjects(platforms, false);

                    if (intersects.length > 0 && intersects[0].distance < (check.ray.equals(downVector) ? config.collisionTolerance : 0.6)) {
                        if (check.ray.equals(downVector)) {
                            currentPlatform = intersects[0].object;
                            state.velocity.y = Math.max(0, state.velocity.y);
                            state.canJump = true;
                            controls.getObject().position.y = intersects[0].point.y + config.eyeHeight;
                        } else {
                            state.velocity[check.ray.x !== 0 ? 'x' : 'z'] *= 0.3;
                        }
                    }
                });

                if (currentPlatform && currentPlatform.userData.type === 'moving') {
                    const lastPos = currentPlatform.userData.lastPos;
                    state.movingPlatformVelocity.copy(currentPlatform.position).sub(lastPos).multiplyScalar(1 / dt);
                    currentPlatform.userData.lastPos.copy(currentPlatform.position);
                }

                pointLight.position.copy(camera.position);

                if (camera.position.y < -35) {
                    triggerDeath();
                }

                if (portal && camera.position.distanceTo(portal.position) < 2.5) {
                    playLevelUp();
                    state.level++;
                    if (state.level > config.maxLevels) state.level = 1;
                    generateLevel(state.level);
                }
            }

            composer.render();
        }

        function triggerDeath() {
            if (state.isDying) return;
            state.isDying = true;
            state.lives--;
            playDeath();
            document.getElementById('death-overlay').style.display = 'block';
            document.getElementById('lives-val').innerText = state.lives;

            if (state.lives <= 0) {
                setTimeout(() => {
                    document.getElementById('death-overlay').style.display = 'none';
                    state.isDying = false;
                    state.isPlaying = false;
                    controls.unlock();
                    alert('⚠️ VITE TERMINATE!');
                }, 1500);
            } else {
                setTimeout(() => {
                    document.getElementById('death-overlay').style.display = 'none';
                    state.isDying = false;
                    generateLevel(state.level);
                }, 1200);
            }
        }

        controls.addEventListener('lock', () => {
            document.getElementById('start-screen').classList.add('hidden');
            state.isPlaying = true;
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('start-screen').classList.remove('hidden');
            state.isPlaying = false;
        });

        window.startGameSession = function() {
            if (state.lives <= 0) {
                alert('Vite terminate!');
                return;
            }
            controls.lock();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        function initGame() {
            generateLevel(1);
            animate();
        }
    </script>
</body>
</html>
